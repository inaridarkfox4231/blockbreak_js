// 暇あったらこれ解析して！！
// バーテックスシェーダ使いこなしたいので

// こっちも解析よろしく！

const vert =
`
attribute vec3 aPosition;
attribute vec3 aNormal;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

uniform vec3 uLightingDirection[5];

varying vec3 vLightDirection;
varying vec3 vNormal;

void main(void) {
  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * viewModelPosition;

	vNormal = normalize(uNormalMatrix * aNormal);
	vLightDirection = -uLightingDirection[0];
}
`;



const frag =
`
precision highp float;

uniform vec4 uMaterialColor;

varying vec3 vLightDirection;
varying vec3 vNormal;

void main(void) {
	vec3 direction = normalize(vLightDirection);
	vec3 normal = normalize(vNormal);
	float intensity = max(0.0, dot(direction, normal));

	vec4 tintColor;
	if (intensity > 0.95) {
		tintColor = vec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 1.0);
	} else if (intensity > 0.6) {
		tintColor = vec4(251.0 / 255.0, 234.0 / 255.0, 200.0 / 255.0, 1.0);
	} else if (intensity > 0.3) {
		tintColor = vec4(250.0 / 255.0, 210.0 / 255.0, 167.0 / 255.0, 1.0);
	} else {
		tintColor = vec4(253.0 / 255.0, 177.0 / 255.0, 150.0 / 255.0, 1.0);
	}

  gl_FragColor = uMaterialColor * tintColor;
}
`;

メインコード

let gl;
let toonShader;
let bg;
let size;
let radius;

function setup() {
	createCanvas(windowWidth, windowHeight, WEBGL);
	pixelDensity(1);
	gl = this._renderer.GL;

	toonShader = createShader(vert, frag);
	shader(toonShader);

	bg = createGraphics(width, height);
	bg.background(147, 194, 198);
	bg.stroke(177, 217, 205);
	bg.strokeWeight(10);
	for (let x = 0; x < max(width, height) * 0.75; x += 40) {
		bg.line(width - x, height, width, height - x);
	}

	size = min(width, height) / 12;
	radius = min(width, height) / 3;
}

function draw() {
	// 背景
	background(0);
	resetShader();
	gl.disable(gl.DEPTH_TEST);
	image(bg, -width/2, -height/2);

	// 星
	shader(toonShader);
	gl.enable(gl.DEPTH_TEST);
	ortho();
	directionalLight(255, 255, 255, 1, 1, -1);
	noStroke();

	for (let i = 0; i < 6; i++) {
		push();
		translate(radius * cos(TWO_PI * i / 6 + millis() / 3000), radius * sin(TWO_PI * i / 6 + millis() / 3000));
		rotateZ(noise(i) * TWO_PI + millis() / 2000);
		star(size, 60, 12);
		pop();
	}
}

function star(size, rows, columns) {
	const gId = `star|${rows}|${columns}`;

	if (!this._renderer.geometryInHash(gId)) {
		const starGeom = new p5.Geometry();

		// 位置ベクトル
		let v = new p5.Vector(0, 0, 0.5);
		starGeom.vertices.push(v.copy());
		for (let j = 0; j < columns - 1; j++) {
			for (let i = 0; i < rows; i++) {
				const theta = - TWO_PI * (i + 0.5) / rows;
				const n = 1.5 + 10 * (1 - sin(PI * (j + 1) / columns));
				const rr = sin(PI * (j + 1) / columns);
				const r = rr * pow(abs(pow(cos(5 * theta / 4), 4)) + abs(pow(sin(5 * theta / 4), 4)), - 1 / n);

				const x = r * sin(theta);
				const y = r * cos(theta);
				const z = 0.5 * cos(PI * (j + 1) / columns);
				v = new p5.Vector(x, y, z);
				starGeom.vertices.push(v.copy());
			}
		}
		v = new p5.Vector(0, 0, -0.5);
		starGeom.vertices.push(v.copy());

		// 面のインデックス
		for (let j = 0; j < columns; j++) {
			for (let i = 0; i < rows; i++) {
				if (j == 0) {
					starGeom.faces.push([0, i+1, (i+1)%rows+1]);
				} else if (j == columns-1) {
					starGeom.faces.push([i+1 + (j-1)*rows, 1 + j*rows, (i+1)%rows+1 + (j-1)*rows]);
				} else {
					starGeom.faces.push([i+1 + (j-1)*rows, (i+1)%rows+1 + j*rows, (i+1)%rows+1 + (j-1)*rows]);
					starGeom.faces.push([i+1 + j*rows    , (i+1)%rows+1 + j*rows, i+1 + (j-1)*rows         ]);
				}
			}
		}

		// 法線・辺計算
		starGeom._makeTriangleEdges()._edgesToVertices();
		starGeom.computeNormals();

		// バッファ作成
		this._renderer.createBuffers(gId, starGeom);
	}

	// 描画
	this._renderer.drawBuffersScaled(gId, size, size, size);
}
