// GLSLでもいいか？ピクセル単位で処理するとか。ステージメーカー的な。で、色取得でステージを作るみたいな。うん。
// となるとエディタも作らないと・・めんど。

// 説明書きはModeのところでやろうね
// 背景は三角形や四角形のコラージュ的な（ランダム配置みたいな）
// 単なるグラデだと芸がないので
// まあロジック移植してからでいいです（テトリスの方もそこら辺いじりたいけどまあいいか別に）（STEP10で）

// ステージエディタがないと話にならないので
// 1x1,1x2,2x1,2x2と黄緑とか緑の壊しにくいやつなどなど灰色の壊せないやつとかクリックでそこに配置されて色情報、
// 色情報からそれを元にして・・
// データとしてはどこにどのブロックがあるってだけの話だから。
// ビジュアルだけ分かりやすくしてそれとは別にどこ・・jsonの方がいいな。saveJSONってあるからこれ使うね
// イメージ：{"blue1":[[2, 3], [4, 7], ...]}
// 左上のグリッド番号の配列。存在するものすべてについて。jsonのまま保持しておいて
// アイキャッチに来るたびに実物（ブロッククラスの集合体）に変換し終わったら破棄する
// 作るやつは別に作る(22x13らしい), ひとつひとつが20x20なので440x260だけどそれと別にいろいろ必要そう（ブロック選択とかセーブボタンとか）
// ブロック選択は画像使いたいよね
// ステージ作りとかはまあ、移植なので余計なことは考えなくていいよ

// まああれ、つぶつぶ以外で受けるもの作るにはこれくらいやってデフォールトってわけ。じゃなきゃまたつぶつぶ量産しないといけない
// それもネタ切れになったらおわり
// 厳しいなぁ
// 去年はそれやったせいで熱出してアウトになってそこからピアノやめるとかいろいろ方針転換した
// 今年それやったら下手すると人生詰むんで作戦「いのちをだいじに」で切るべきところはどんどん切っていこう

// エディタは後回し。先にブロッククラスかな。で、パーサー。で、サンプルを作ってそれを元にいろいろテスト。
// ステージもコピペでいい。一つ一つを簡単なシードにして。それで原型を作る。
// エディタはそのあと。
// 装飾はさらにそのあと。長丁場になる。
// 作ってた頃は働いてなかったからエネルギー全注力できたけど今はそれできないから少しずつ少しずつやっていくしかないわね。

// ライフは3, 6, 10, 15でいい気がしてきた。あと難易度丁度いい（気がする）のでこのまま作っちゃおう。
// 衝突判定単純でした。バリデーションかけたあと、移動後に衝突するならそれを使う感じで、あとぶつかった時の反射はその
// calc_is_farを使ってバリデーションかけてる、これがあれの時は判定に使わない、的な感じのあれ。
// colliderに相当するのはrectでしょう。これでいいか。
// つまりボールはrectと思ってやってるのね。

// サイズの確認
// 各ブロックは20x20が基本で最大で40x40とか20x200とか200x20
// ボールは16x16
// パドルは横幅が80,60,40,30で縦幅が5です（薄い）

// 簡単にまとめるね
// ブロックについて、色ごとに当たると色が薄くなっていく仕様にする。で、
// a0～a4,b0～b4,c0～c4,d0～d4が例の5種類とする、0～4はタフネス、これが0の時に当たると消えるみたいな。
// e0,e1,e2については緑、黄緑、スカイブルーで高速時じゃないと壊せない感じで0,1,2がタフネス
// 高速かどうかはボールクラスの速度いじって決めたり
// f0～f9とg0～g9は壁ブロック
// h0,k0は1UPでこれは横と縦がある(横がh0で縦がk0みたいな)
// プロパティmustがtrueのものをすべて壊してかつエフェクト配列が空っぽならゲームクリア
// 色別にしたいのはパーティクルをカラフルにしたいから（オレンジと黄色と緑しか出ないんじゃつまんない）
// ブロックが壊れるときに位置と色が指定されてエフェクト、これが一定フレームで消える。

// playのinitializeで難易度ごとにライフ設定（レベルごとにずっと継続）でスコアも0にリセット
// これはmodeからeyecatchに行くときにnode経由で直接指示を出す

// ボールやパドルやブロックのxとかyは左上の値とする、とはいえブロック動かないからrectだけでいいんだけど。じゃあ要らないか。
// パドルについてもupdateってマウス位置にパドル置くだけだし。難易度で幅が決まり、それとマウス位置からパドルの位置が決まる。
// じゃあボールだけか。で、update詳細。
// まずブロックは動かない、パドル位置をマウス位置に応じて更新。
// 次にボールとパドルを見てボールに速度足した時のcolliderがパドルとぶつかるようなら反射処理する
// 平板か角かで処理が異なるがいずれも速度をいじる「だけ」で面倒なめり込み処理は行なわない
// それをやって速度が場合によっては変化してからブロック群と衝突判定
// 具体的にはやはり速度足したときのcolliderがぶつかるかどうか見る
// それでぶつかるなら速度を変える、やはり平板か角かで処理を分けるが・・
// アクションについてもいろいろ。たとえばブロックが壊れるとか1UPするとか
// そしてやはり速度をいじる「だけ」でめんどくさいめりこみ処理は行なわない。
// もろもろのあと速度によりボールの位置を更新して終了。colliderのupdateも忘れずに・・
// っていっても使うのって速度足したやつのcolliderじゃん、やっぱ使えねぇ・・collider要らないかも？
// wとhとxとy(というかleftとtop)があればいい気がしてきたわ（そうです）
// そのあとエフェクトのアップデート、これはstageDataがplayの配下としてあってこれをupdate,
// stageDataのブロック群でmustのものがひとつもなくeffectsも空っぽならクリア判定。以上。

// colliderはやっぱ円判定で互いに動き回っていてこそよね

// 800x600にしてステージごとに大きさを変える、で、ライフとスコアはそれに応じた位置に表示する、的な？
// 今、全体の大きさが440x400でやってて、それに対して壁、があって、って感じ。つまり、
// で、それを円形とか、両サイドとかにする場合、stageseedにその情報を入れて、playに渡して、スコア描画とか
// やる際の参考データにする必要があるってわけね。
// ブロックの配列は直接渡していいけどstageDataそのものも必要だと思うんだ。うん。
// 背景画像を別に用意して、それもplayと共有しつつ・・それの上に黒でエリア、で、画面外にライフとスコア、
// 黒の地にブロックを配置して・・ガーターね。とげでいい。三角。20x20の三角。それをずらっと。
// それと別にパドルの移動データ。というか、マウス位置(x,y)をパドル位置に変換する関数、ね。それのコードみたいな。
// 番号だけ指定しておいて具体的な指示はこっちで変換するからそれを使うのだよ。グローバルに用意しておいて。

// とはいえ、今もういろいろ準備しちゃったから800x600にするのは後回しでいいよね。疲れちゃう。

// ばかばかしくなってきたので合理的に考えよう。これじゃ一生出来上がらない。
// 絵面とかとりあえずどうでもいいから合理的に考えてよ。
// まず
// ノーマルブロック
// 色は青系で統一(HSB=65)。タフネスで色の濃さ指定(20, 40, 60, 80, 100)。薄い→濃いで1～5.つまりぶつけるほどうすくなってく、濃いのはつよい。
// ハードブロック
// 色は赤系で統一(HSB=0)。薄い→濃いで2,4,6. (20, 60, 100)
// ライフアップブロック
// 色はピンク(HSB=87)で当てると1ライフ回復
// ウォールブロック
// 色は灰色で壊せない。
// グラフィックは用意しない。タイプとタフネスで描画内容を完全に指定する。以上。
// とりあえず外周を灰色で覆うくらいはしないと隣接ブロックを区別できないけどね・・
// ていうかHSBのSを半分にしてベース、Bを半分にして・・くらいはいいんじゃない。

// wとhは事前に設定
// createGraphicsも実行済み
// 作るのはブロックそれ自体に対してtypeとtoughに応じて画像を提供する関数
// グローバルの
// それを用意して衝突でタフネスが減るたびに基本のHSBに対してさっきみたく形を与える感じで。
// 灰色とかはだから最初に用意してそれっきりね。
// それでいこう。

フローチャート
パドルをマウスで動かす
ボールを固定して
左クリックで発射出来るようにして
右クリックでパドル強化
するとボールの速さが変わる
そうしないと

じゃなくてね

次にやることは？

登場するのは

2021/02/09/03:21
お誕生日おめでと！自分に！

それはいいとして（いいのかよ）
んーーーー。。。
テンプレート見直す必要があるわね・・このまま文章書き連ねてもなんかあれ、えたーなる気しかしない
何とかしないとね
根本から見直す必要がある
テストもしやすくしないと
テトリスは簡単だったから全体像ほぼ作り上げてからテストしてもすんなりハマったけどこれはそういうわけにはいかなそう
なんだけど多分それは思い込みで
普通にやれば骨組みつくれるはずなんだよ
だから見直す
骨組みを作り肉付きを作る
その手順で行けばやれる

gameSystemクラスを作って独立させる
今現在「stageData」とかいう名前で運用しているところのそれを・・gameCore？
GameCoreクラスを作る。
class GameCore{
  constructor(seedNumber){
    以下略
  }
}

// 違うだろ
メソッドで
setPattern(patternId){}
とかやる、jsonはグローバルでダウンロードしたものを使う、って感じじゃねーの。で、setのたびに
paddle集合とかマウス操作による動かし方、なんやらかんやら、そういう感じだと思うよ。
STGコードのあれ、あれを意識すると構築しやすいかも。

class GameSystem{
  constructor(){
    this.paddles = [];
    this.ball = new Ball();
    this.blocks = [];
    this.gutter = new Gutter();
    this.board = undefined; // createGraphics()で指定された大きさの画面を作る
    // 付属品
    this.score = 0; // 加算されていく
    this.life = 0; // 難易度を受け取った時にパドルの太さなどの情報と一緒に・・
    this.difficulty = 0; // 難易度情報を受け取る。ステージ番号と一緒に。このデータが無いとパドル生成の時困る
    // ステージ番号は使う機会がない。StartとPlayだけ持ってればいいんじゃない。むしろ操作用の情報って感じ
    this.effects = []; // ブロック壊れたりボール消えたりするときにエフェクトが生成されてここに。
    // 条件としてはエフェクトが空っぽで
    // 1.ボールがaliveしてなくてlifeが正→Startに戻る
    // 2.ボールがaliveしてなくてlifeが0→Gameoverに移行
    // （これ以降はボールがaliveが前提、ボールがnot aliveの場合上の二つに強制的になる、たとえブロックがひとつもなくてもね）
    // 3.ボールがaliveでブロックが空っぽ→Clearに移行することを伝える。
    // その情報を受け取ったplay側がstageNumberを見たうえでClearかAllClearに移行、まあどっちにしろClearなわけだけど。
    // ClearにscoreとstageNumberを伝えてstageNumber次第ではScoreに移行させる、かどうか。まあlifeを用いた
    // score計算とか考えるとあった方が、いいね。
  }
}

// もしくは一旦Playに渡したうえで直後にStartでまたPlay,ってやった方がいいのかも？
// Startからのprepareでこれのsystemがおねむのときに、みたいな。そうでないときは別の処理
// GameSystemの状態：activeかそうでないか。ゲームが始まってない段階なら・・・？
// え？
// Startが要らない・・まあ、そういえばそうか・・そうね・・Start要らないか・・んー。
// eyecatchは残すよ、番号コールするだけだからあれ。

// Start廃止になりそう
よく考えたらパドルやボールの状態が違うだけだし
場合分け面倒だけどStartの微妙な立ち位置に配慮する方がよほど面倒
メインでないStartでGameSystemを稼働させるのもなんか不自然だし
さらにいうとeyecatchも要らないのか？ぼまふぉ（ボマーフォックス）みたく番号コールアニメーション流せばいいだけだろ。
Playだけでいけるな・・・シンプルな方がいいよね。

/*
ゴミ箱
// ステージ開始前のスポットみたいなやつ
// まあステージ番号コールするだけ
// ここでステージデータを作っちゃう（Startに渡してPlayにも渡す）
// データはクラスの形にすべきかな
// シードはjsonか画像データかまあ別に作ってそれを元にデータを生成する流れ
// Modeからの場合はstageNumberをlevel * 5 - 4で計算（1,6,11,16,21）,difficulty情報をmodeから取得
// Clearからの場合はそのままでOK. difficultyはmodeから来た時に設定された値がそのまま保持されているし、
// このあとStart経由でplayに設定されたらクリアかオーバーまでずっと保持されるから設定の必要なし。
class Eyecatch extends State{
	constructor(_node){
		super(_node);
		this.name = "eyecatch";
		this.stageNumber = 0; // 1～25
		this.difficulty = 0; // 1～4
		this.frame = 0;
	}
  drawPrepare(){
		this.gr.textAlign(CENTER, CENTER);
		this.gr.textSize(64);
		this.gr.textFont(huiFont);
		this.gr.fill(255);
	}
	prepare(_state){
		switch(_state.name){
			case "mode":
			  this.stageNumber = _state.level * 5 - 4;
				this.difficulty = _state.mode;
				break;
			case "clear":
			  this.stageNumber = _state.stageNumber;
				break;
		}
		this.frame = 0;
	}
  keyAction(code){
		// 自動的に移行するので操作は無し
	}
	update(){
		this.frame++;
		if(this.frame == 60){ this.setNextState("start"); }
	}
	draw(){
		this.gr.background(0);
		this.gr.text("STAGE" + this.stageNumber, CANVAS_W * 0.5, CANVAS_H * 0.5);
		image(this.gr, 0, 0);
	}
}

// ここでステージナンバーを元にステージデータを生成し
// それに基づいて描画させる。ステージデータはgraphicを受け取りそこにブロックを追加で描画するだけの処理。
// ステージデータのブロック画像から切り貼りするだけだからgrへの操作は不要。imageしか使わない。
// eyecatchからくる場合とplayから来る場合（やられたとき）があるがステージ生成処理はeyecatchから来るときだけ行なう（当然ね）
// どっちからくるにしても初期化処理を行なう（難易度に応じて）. paddleとか画像もcolliderも異なるので。位置とかも。

// とりあえずstagedataにダミー入れてテストだわね
// ここから先はもろもろ用意しないとどうしようもないな
class Start extends State{
	constructor(_node){
		super(_node);
		this.name = "start";
		this.data = undefined;
		this.stageNumber = 0;
		this.difficulty = 0;
		this.ball = new Ball(); // パドルと一緒に動くだけ。発射時に位置情報をplayに渡す
	  this.paddle = new Paddle(); // パドルはマウスと一緒に動く。発射時に位置情報を以下略. 難易度情報は初めに1回だけセットする
	}
	initialize(difficulty){
		this.ball.initialize(difficulty);
		this.paddle.initialize(difficulty);
	}
  drawPrepare(){}
	prepare(_state){
		switch(_state.name){
			case "eyecatch":
			  this.data = new Stagedata(_state.stageNumber); // stageNumberによりステージを生成。
				this.stageNumber = _state.stageNumber; // まあdataに入ってるけど一応ね
				this.difficulty = _state.difficulty; // 難易度が無いとパドルを作れない
				break;
		}
		// どっちからくるにしてもresetは必須
		this.ball.reset();
		this.paddle.reset();
	}
  keyAction(code){
		// マウス操作だから特に・・
	}
	update(){
	}
	draw(){}
}
*/

ゲームの流れ（Title～Mode）
Title → Select
Titleでエンターキー押すとSelectに移行する。おわり。
Select → Mode, Title
Selectでは十字キーでレベル（ステージが5つ集まったもの）を選びます
レベル0～4でエリア0～4ってやる感じ
ステージはレベル*5+エリアナンバーって感じで。
レベル、エリア、ステージ
名前の定義、割と大事。
セレクトでレベルをセレクト、モードでモードをセレクト。んー・・・
セレクトでレベルとモードをセレクト？ってやるべき？
じゃあいっそ「SelectLevel」と「SelectMode」って名前にしちゃえ。
difficultyはやめてmodeで統一。統一するの大事。
今までmodeとしていたものは混乱を避けるためchoiceという名前に変更する
TO TITLEの場合はタイトルに戻る
Mode → Select, Play

Title → SelectLevel → SelectMode → Play からのPauseとClearとGameoverとScore ですべて。めでたし！
SelectLevelとSelectModeにおけるカーソルの番号はchoiceという名前で統一
0ベースで戻る場合は0だけどそれだと1～5とか1～4になっちゃうから渡すときに1を引くのを忘れないこと
下に戻るを設定してもいいんだけどまあいいやそれは
レベルごとのステージ番号は・・
{"level0":{"stage0":~~~, "stage1":~~~, "stage2":~~~, ...}}
いいや、エリア要らね。レベルとステージで行こう。めんどうでしょ。
ステージ作るときに(level, stage)でそれぞれ数入れて・・って感じで。
jsonにはlevelごとのstageごとみたいな感じで入れて選択できるようにするよ。通し番号は、無しで。

こっちは常に複雑さを避けてシンプルにやろうと思ってるんだけどなかなかうまくいかないのよね。
何でだろうね？？

systemSetupとかいうインチキ処理を抹消
こういうわけわからんことするからどんどんスパゲティ化していっちゃうんだよ
ふざけんな

右クリックでボール発射やめます
普通に左クリックでいいです
それで、クリックしたあとしばらく（32フレームくらい）クリック出来ないようにすればいいでしょ。それでいけるはず。
32っていうのは30よりちょっと大きいくらい。パドルのアクティブ時間が30フレームだからそれより大きくないといろいろと不便なので。
playにclickSpanっていうの持たせて、それが32になって、毎フレーム、正である限り減って、0のときしかクリックが作動しないように。

とりあえずplayまで動くようにするのを目標にします。そのあとのことは、そのあとで。

ライフはボール持ちにしてください。ブロックのhit関数で変化させたいので。いちいち呼び出すのめんどくさい。

つぶつぶだと全く反応されない
クソが
やっぱきちんとゲーム作らないとダメね
でも体壊したらアホみたいだからほどほどにする

ひながた作るまでが遠い・・・・・

ポインターはパドルにボール変数持たせて基本undefinedにして0番に持たせてアクティブになったら外して
ボールが消えたらまた0番に持たせてっていうのを延々とやります
シフトキーでパドルを移れるようにしたい。それは今後の課題。
まずは・・
あとパドルに向きを持たせる。ラインの場合向きは固定。アークの場合は外向きか内向きかを指定。
ベクトルの方向を渡す。たとえば1,0とか0,-1とか。それが向きになるとして、アークの場合は0,1なら内向きで0,-1なら外向きとする。
3つ目。これで最後。衝突関連はcolliderに任せる。長方形と円弧でOK. その継承として、リフレクターというのを用意して、
ボールを渡して、速度の変更を為すというものを作る。
その前段階のcolliderをガターに流用する。ガターも円弧と長方形からなるので。その配列にしちゃう。で、
それらのうちどれかとかぶる場合にアウト、ってやればいいんだね。
rectの指定方法：x,y(左上),w,h(横幅縦幅)arcの場合は
まあrectっていってもlineだけど・・lineの当たり判定にrect使おうってだけの話（斜めの線は使いません）
arcの場合は中心座標と長さと半径と方向角(cx,cy,l,r,t)で長さにより決まる。tの方向、両側にlだけ。
r * theta = lだからtheta = l/rでこれの半分だけtの±で範囲。以上。

カウントもパドル持ち、か。まあそうなるわな。
