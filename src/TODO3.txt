さてと。
どこからPlayに来るのか
うん
SelectModeから来るのはLevel開始時の1回だけ
それ以外はClearから来ることになっている
Playでやることは多いので整理する

SelectModeから来たら
1.スコアを0に戻す
2.レベルとモードの情報を登録してステージ番号を0に戻す
3.モード情報をもとにボールのライフを設定する
以下は共通の処理
4.ボールのデータをリセットする（ライフには手を付けないで）（何をリセットするかはおいおい）
5.レベルとステージ番号とモードからjsonの一部を切り出してステージのデータを取得
  それを元にパドル配列、ボール、ブロック列、ガターの準備を行なう
  この「準備」でつまづいちゃってるのよ
  内容に関してはPlayのupdateとdrawで何をやるかから調べるべき

Playでやること
一番最初はステージ番号を60フレーム表示しないといけない（以降は番号が左上に表示される）

グラフィックの表示に成功。一歩前進。2021/02/11

形ができてきたら選択肢の作り方も洗練させて動かしやすくしたいわね

ステージ番号の表示に成功。2021/02/11

ガターは画像先に作っといてdrawはそれを貼り付ける、gameSystemのgrに。
そのうえで別に当たり判定を用意する感じで。
反射についてはcolliderに直接用意する、継承とかはしない感じで。
ブロックは描画の仕方は性質から決まる、それとは別に当たり判定。
パドルも描画の仕方はパラメータから、それとは別に当たり判定。それでいく。
まず描画だけする
ボールもあらかじめ画像つくっておいてそれを貼り付ける方向で。大きさが変化しないのでその方がいいね。

ガター、パドル、ボール。最初はそこから。ブロックはあとで。
ガターの表示に成功。やったね！
先にブロック
2つ用意しました。おけおけ。

まずブロックね

パドル作れ。
パドル動かしたよ。ボール作って。さらに乗せる。
乗せたよ。

クリックでボールが出るようにする
衝突はしなくていい
ブロック飛んだ。じゃあ衝突判定（明日以降ね）

お目汚し失礼しました。（？？）ああ、こっちのこと。関係ない。引き続き、よろしく。

ブロックで反射するようになったので次はガターですね。で、アウト判定すると。

次はゲームオーバーの処理作ってください
あとボールがやられるときに一瞬だけポインターが出るのなんとかして
解決した
ゲームオーバーね。おけおけ。
じゃあクリアつくろうか。でもその前にブロック壊せないといけない。パーティクルは後回しでいい。
もうブロックにはぶつかれるんだから、・・その前にパワーアップか。パワーアップでしか壊せない仕様作ってあるんだし。

--------------------------アイデア------------------
えーと、斜めのブロック。円状のブロック。そんなとこ。あと、ボールのパワード状態の持続を円で表すなど。
それから
---------------------------------------------------

順序
０．パドルのアクティベートをもうちょい分かりやすく。
１．パワーアップ作る（2段階）
２．パワーアップの時間継続を表現（といっても円弧描くだけでいい）
３．ブロック壊す仕様を実装
４．クリア実装
５．オールクリア実装
６．ポーズ機能。ひとまず完成
７．まだまだいっぱい・・とりあえず、パーティクルとかステージ番号とかその辺。

仕様変更。パドルはクリックのたびにアクティブとノンアクティブを切り替えられるようにする。以上。
あと、マウスの0~1を画面のサイズに対応させるのもよろしくね
おっけー
じゃあクリア判定。NORMALをすべて壊したら終了です。確定事項。
形はrectだったり円だったり色々。とにかくすべて壊す。
んー・・40x40とか分裂するのもあれ、まあいいや。
スペースキーでポーズと切り替え

パドルとの衝突について。端っこの場合に・・です。
やっぱ側面はスルーさせないとだめね・・オプションで何とかするか。

おはよー
ガターをパドルすれすれにしたら平和が訪れた。いぇい。
じゃあ次はアークパドル作るかな。円環型のガターも作らないと。

// なんかもうめんどくさいから全部クリックで済ませるのもありかな
// タイトル画面に説明との行き来だけ用意してあとクリックでモード選択してクリックでレベル選択してスタートするの。
// 今はいいや。

// タイトルの下に矢印クリックしてモード選択、ステージも選択。で、playクリックしてplayスタートみたいな。

で、次にやること・・あの、えー。gameSystemはcolorMode(HSB, 100)にする。で、ブロック色んな色を出したい。
タフ0は全部白でいい、1と2についてそれをカラーで。

色はいいよまた今度で。
それよりアーク。それ終わったらテスト。それ終わったらステージ作ったりやることいっぱいあるんで。


ごめん
やっぱ色でタフさを表現するやり方に戻す。
もうその方がいいと思うから。それ、今なら可能でしょ・・黄色 オレンジ 赤 紫 青でOK. ピンク。そして硬いブロックは
硬いブロックで別に。えーと、硬いブロックの場合は・・めんどくさい
赤より上なら硬いから強い攻撃が要る。で、いいじゃん。オレンジまでなら通常アタックで壊せる。それで行こう。はい。
18, 10, 0, 78, 65です。これを配列に。ピンクは88で。

そうね
当たり判定・・んー。じゃあ、えーと、かどっちょで±15°だっけ。じゃあね、その範囲で補間するか。線型補間でいいか。
と思ったけどパドルだけにしないとめんどいことになるね。ああもう。。。
でもまあいいか。

ぶつけたときのブロックのタフさに応じて音を出す。CDEFGの和音とかその辺。あとLIFEUPはLの文字出すといいかも。

タイトル画面から直接ゲーム画面に飛んだ方がいいって言われたのでそうするみたい。

修正点まとめ
タイトルでクリックでレベルと難易度選べるようにする
色は選ばれてないのを灰色にするくらいで選ばれてるのを色付ける。同じ色でいい。
エンターキーでも移行できるようにするがクリックスペースを設ける（playって書く）
それぞれパーツごとにグラフィックでまとめて全体をセンタリングして配置
ボールの周囲に円を用意してそれが小さくなっていくことでリミット表現
パドルのアクティブは今のままで・・とりあえず
効果時間は120フレームやっぱ用意しないと面白くないだろということで

/*
廃止
class SelectLevel extends State{
	constructor(_node){
		super(_node);
		this.name = "selectLevel";
		this.choice = 0;
		this.choiceLength = 6; // 0:TO TITLE, 1～5:各レベル（実際は0～4）
		this.txt = ["TO TITLE", "LEVEL 0", "LEVEL 1", "LEVEL 2", "LEVEL 3", "LEVEL 4"];
		this.base = createGraphics(CANVAS_W, CANVAS_H);
		this.drawPrepare();
	}
  drawPrepare(){
		this.base.background(40, 128, 255);
		this.gr.textSize(30);
		this.gr.noStroke();
		this.gr.textFont(huiFont);
	}
	prepare(_state){
		// choice変数を0に戻さないと
		this.choice = 0;
	}
  keyAction(code){
    // 上下キーで選択、エンターキーでtitleまたはmodeに移行
    switch(code){
      case K_UP:
        this.choice = (this.choice + this.choiceLength - 1) % this.choiceLength;
        break;
      case K_DOWN:
        this.choice = (this.choice + 1) % this.choiceLength;
        break;
      case K_ENTER:
        if(this.choice === 0){
          this.setNextState("title");
        }else{
          this.setNextState("selectMode");
        }
        break;
    }
	}
	update(){
		// そうね・・やること、ないわね・・
	}
	draw(){
    this.gr.image(this.base, 0, 0);
		let col = [0, 0, 0, 0, 0, 0];
		col[this.choice] += 255;
		const left = 135;
		if(col[0] > 0){ this.gr.fill(0); this.gr.rect(left, 40, 130, 30); }
		this.gr.fill(col[0]);
		this.gr.text(this.txt[0], left + 2, 63);
		for(let k = 1; k < 6; k++){
			if(col[k] > 0){ this.gr.fill(0); this.gr.rect(left, 70 + 50 * k, 183, 30); }
			this.gr.fill(col[k]);
			this.gr.text(this.txt[k], left + 2, 93 + 50 * k);
		}
    image(this.gr, 0, 0);
	}
}

// このページで操作説明する
// 難易度はEASY, NORMAL, HARD, CRAZYの4種類でいこうか（同じ仕様でやる）
// 難易度ごとに色変える感じで（青→緑→黄色→赤）
class SelectMode extends State{
	constructor(_node){
		super(_node);
		this.name = "selectMode";
		this.base = createGraphics(CANVAS_W, CANVAS_H);
		this.level = 0; // selectからレベルの情報を受け取る。playに渡す。
		this.levelText = ""; // STAGE--～--のテキストをコピーする感じ
		this.choice = 0; // playのdifficultyとなる値。modeという名前になってるのは、要するに選択画面では常に"mode"という名前を使うってだけの話。
		// playの方でlevelとdifficulty,更にステージ番号1～5に応じてステージが生成されてゲームが行われる
		// ライフ0になったらタイトルに強制的に戻されクリアの場合は次のステージに進み全部クリアしたらやはりタイトルに戻る（スコア表示後）
		// セーブ機能は無いけどまあスコアがセレクト画面に記録されるくらいはいいかなって思うけども（クッキー使う？）
		this.choiceLength = 5; // 0:TO SELECT, 1～4:難易度。
		this.txt = ["TO SELECT", "EASY", "NORMAL", "HARD", "CRAZY"];
		this.drawPrepare();
	}
  drawPrepare(){
		this.base.background(128);
		/* ここでインストラクション書いた方がいいかもなぁ */
		this.gr.textSize(30);
		this.gr.noStroke();
		this.gr.textFont(huiFont);
	}
	prepare(_state){
		// モード変数を0に戻す。
		this.choice = 0;
		// ModeにはSelectからしか来ることができないのでlevelをここでSelectの情報を元に設定
		this.level = _state.choice - 1; // 0～4
		this.levelText = _state.txt[_state.choice]; // それに応じたテキスト
	}
  keyAction(code){
    // 上下キーで選択、エンターキーでselectまたはplayに移行
    switch(code){
      case K_UP:
        this.choice = (this.choice + this.choiceLength - 1) % this.choiceLength;
        break;
      case K_DOWN:
        this.choice = (this.choice + 1) % this.choiceLength;
        break;
      case K_ENTER:
        if(this.choice === 0){
          this.setNextState("selectLevel");
        }else{
					// SelectModeからplayに行くときとclearからplayに行くときで処理を若干変える。
					// 仕事はほぼgameSystemに一任する。
          this.setNextState("play");
        }
        break;
		}
	}
	update(){
		// まあ、やることは、ないわな・・
	}
	draw(){
    this.gr.image(this.base, 0, 0);
		let col = [0, 0, 0, 0, 0];
		col[this.choice] += 255;
		const left = 35;
		const top = 80;
		this.gr.fill(0);
		this.gr.text("--" + this.levelText +" is choosed--", left + 2, top + 23 - 50);
		if(col[0] > 0){ this.gr.fill(0); this.gr.rect(left, top, 140, 30); }
		this.gr.fill(col[0]);
		this.gr.text(this.txt[0], left + 2, top + 23);
		for(let k = 1; k < 5; k++){
			if(col[k] > 0){ this.gr.fill(0); this.gr.rect(left, top + 30 + 50 * k, 103, 30); }
			this.gr.fill(col[k]);
			this.gr.text(this.txt[k], left + 2, top + 53 + 50 * k);
		}
    image(this.gr, 0, 0);
	}
}

*/

先にshoot, 去年作ったあれ、からパーティクルシステムを拝借してこっちに利用させてもらう。
ブロック壊すときはhopなし、ボールが砕け散る時はhopありで。ブロックの方は星型、ボールの方は四角形辺りかな・・
あとガーターはそのうち以前作ったラーヴァでやりたいかも。その、シェーダで・・特定の場所だけそれで・・

衝突点から出るように修正して。ボールの側で位置に速度足せばいい（中心に速度方向だけ半径で）

円形ブロックは短調にするとかしたら面白そう

ブロックが全部壊れたらボールは停止、ってやった方がいいのと
あとパドルが端っこまで行かないように修正、それでもダメっぽいけどね・・んー仕方ない。
アイデアとしては、NORMALが全て壊れているというフラグと、パーティクルがすべて無くなっているというフラグを用意して、
NORMALがすべて壊れているフラグが立った時点でボールの移動をやめ、
双方のフラグが揃った時点でクリア判定とする、というものかな。

もうパドルめんどくさいな
どうしたって例のバグは避けられない
かくなるうえは両側ループさせるしかないかもしれない
それか強制的にワープさせるとか

はい
なるほどね。ガターチェックはそのときの位置に対してやるけど反射処理は違うと、そこら辺ですね・・・
んー。。やっぱ分けた方がいいかな・・速度足しちゃうのはまずいわ。
ガターチェックでは重なるかどうかしか見ないからな。そこは、確かにまずい。

めり込みどうしたら避けられるの・・もうわからん
どうやら真剣に両側ループを考えないといけない・・・？それか周囲マグマにしちゃうとか。
周囲マグマにしてパドル4本用意するとかね。そうすればめり込みようがない。ねぇ？（ねぇじゃねぇよ）

プレイ画面の背景、歯車とか過去のスケッチとかでもいいかもね。

関係ないけどこれの解析よろしくね（なぜ・・・）
https://twitter.com/zozuar/status/1361344020778221579
N snoise2D(p.xz
float i,g,e=1.;for(vec3 p;i++<2e2&&e>.001;){p=vec3((FC.xy-r*.5)/r.y*g+1.,g);
p.y-=.5*g;e=p.y-N-t*.5)*.02+N*2.+t)*.01;
g+=e*.5;}o+=sqrt(cos(i/2e2))*vec4(.1,.36,.4,0)+sin(i/5e2)*vec4(9,3,1.6,0);

当面の目標
上のシェーダー解析
エディタ作る
弾避けゲームのアイデア出す
以上～

パターン1:下面にパドル1個
パターン2:上面と下面にパドル1個ずつ
パターン3:両サイドにパドル1個ずつ
パターン4:中央に反対向きにパドル背中合わせ1個ずつ
パターン5:上下左右4方向にパドル1個ずつ
とりあえず壊せるブロックの配置のところを簡略化しようね
上60の部分は確定なのでそれはおいといて
円形ブロック用意した方がいいと思う
ringWallsはこれでOK.

ゲームスタート時のアニメーションの・・レンガ状に分割してそれぞれのパートでその、右から左にぐーっと。
長方形ごとに色々ある。ブラインドが。レベルごとに違うブラインドを用意したら面白いかもね。
120フレームにして60,60でそれぞれ。うん。
レベル1～5はそのまま移植でいいと思う。6～10で、
6:上下に左右パドル。600x600
7:左右に上下パドル。600x600
8:上下左右にパドル。600x600
9:左右に上下パドル、まんなかにも上下パドル。800x640フルサイズ
10:上下に左右パドル、まんなかにも左右パドル。800x640フルサイズ。

// LIFEUPのブロック、今日作ったハートマーク付けようっと
